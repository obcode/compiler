% Compiler  
 Â --- Parsers ---
% Prof. Dr. Oliver Braun
% SS 2014

## Parsing

-	Parsing is the second stage of the compiler's front end

-	input is the stream of words generated by the scanner

-	the parser derives a syntactic structure for the program by fitting
	the words into a grammatical model of the source language

-	if the parser determines that the input is a valid program

	-	it builds a concrete model of the program

-	if the input is not valid, it reports the problem and the appropriate
	diagnostic information

-	as a problem, parsing has many similarities to scanning

-	the theoretical basis for parsing techniques has been studied extensively as
	part of formal language theory

## Expressing Syntax

-	in practice we need a notation to describe the syntax and check it

-	we worked with one such notation: regular expressions

-	but REs lacks the power to describe the full syntax of most programming
	languages

-	for most languages, syntax is expressed as **context-free grammar** (CFG)

## Why not Regular Expressions?

-	consider the problem of recognizing algebraic expressions over variables and
	operators

-	the RE $[a...z]([a...z]|[0...9])^* ((+|-|\times|\div)[a...z]([a...z]|[0...9])^* )^*$ 

	-	contains nothing about a notion of operator precedence, e.g., in $a+b\times c$

-	so we can try to add parentheses to our RE, resulting in
	$(\backslash(|\epsilon)[a...z]([a...z]|[0...9])^* ((+|-|\times|\div)[a...z]([a...z]|[0...9])^* )^*(\backslash)|\epsilon)$

	-	this RE can produce an expression enclosed in parentheses, but not one
		with internal parentheses

-	so we can try to move the parentheses inside the closure
	$(\backslash(|\epsilon)[a...z]([a...z]|[0...9])^* ((+|-|\times|\div)[a...z]([a...z]|[0...9])^* \backslash)|\epsilon))^*$

	-	but this accepts $a + b) \times c)$

-	in fact we cannot write an RE that will match all expressions with
	balanced parentheses

## Context-Free Grammars

-	a context-free grammar $G$ is a quadrupel $(T,NT, S, P)$ where

	-	$T$ is the set of terminal symbols, or words, in the language $L(G)$.
		Terminal symbols correspond to syntactic categories returned by the scanner.

	-	$NT$ is the set of nonterminal symbols that appear in the productions of $G$.
		Nonterminals are syntactic variables.

	-	$S$ is a nonterminal designated as the start symbol.

	-	$P$ is the set of productions or rewrite rules in $G$. $P$ has the form
		$NT \mapsto (T \cup NT)^+$ 

## Backus-Naur-Form

-	we usually give the productions of a CFG in Backus-Naur-Form (BNF)

	-	Extended BNF (EBNF) [[ISO standard](http://www.cl.cam.ac.uk/~mgk25/iso-14977.pdf)]

	-	for Augmented BNF (ABNF) [[RFC](http://www.cl.cam.ac.uk/~mgk25/iso-14977.pdf)]

## Examples

-	a sheep's speech:

    ------------ --------- ------------------------------------
    *SheepNoise* $\mapsto$ `baa` *SheepNoise*
                 $|$       `baa`
    ------------ --------- ------------------------------------

-	the language of expressions with parentheses

	--- ------ --------- ------------------------------------------
	$1$ *Expr* $\mapsto$ ( *Expr* )
	$2$        $|$       *Expr* *Op* `name`
    $3$        $|$       `name`
    $4$ *Op*   $\mapsto$ +
    $5$        $|$       -
    $6$        $|$       *
    $7$        $|$       /
	--- ------ --------- ------------------------------------------

## An example generation

-   beginning with the start symbol *Expr* we can generate the sentence $(a+b)*c$
	using **rightmost derivation** by the rewrite sequence (2,6,1,2,4,3) 

    <!-- http://mshang.ca/syntree/ -->
    ![parse tree of  $(a+b)*c$](img/03/parsetree1.png)

-   **leftmost derivation** uses the sequence (2,1,2,3,4,6) and, obviously, results
	in the same parse tree

## Ambigious grammar

-	for the compiler it is important that each sentence has a unique rightmost
    (or leftmost) derivation

-	if multiple derivations exist for some sentence, the grammar is called
	**ambigious**

-	such a grammar can produce multiple derivations and multiple parse trees

-	multiple parse trees imply multiple possible meanings for a single program

## The classic example of an ambigious construct

--- ----------- --------- -------------------------------------------------
$1$ *Statement* $\mapsto$ `if` *Expr* `then` *Statement* `else` *Statement*
$2$             $|$       `if` *Expr* `then` *Statement*
$3$             $|$       *Assignment*
$4$             $|$       *...other statements...*
--- ----------- --------- -------------------------------------------------

can result in the two different parse trees:

![](img/03/parsetree2.png)

![](img/03/parsetree3.png)

## `else` without ambiguity

--- ----------- --------- -------------------------------------------------
$1$ *Statement* $\mapsto$ `if` *Expr* `then` *Statement*
$2$             $|$       `if` *Expr* `then` *WithElse* `else` *Statement*
$3$             $|$       *Assignment*
$4$             $|$       *...other statements...*
$5$ *WithElse*  $\mapsto$ `if` *Expr* `then` *WithElse* `else` *WithElse*
$6$             $|$       *Assignment*
--- ----------- --------- -------------------------------------------------

## Encoding Meaning into structure

-   by parsing the expression $a+b*c$ using the former rules we get

    ![](img/03/parsetree4.png)

-   one natural way to evaluate the expression is with a simple postorder tree walk

-   but that gives us $(a+b)*c$ and not $a+b*c$ since we have not encoded
    operator precedence in the grammar

## Encoding operator precedence

--- --------- --------- ----------------------------------
$0$ *Goal*    $\mapsto$ *Expr*
$1$ *Expr*    $\mapsto$ *Expr* + *Term*
$2$           $|$       *Expr* - *Term*
$3$           $|$       *Term*
$4$ *Term*    $\mapsto$ *Term* * *Factor*
$5$           $|$       *Term* / *Factor*
$6$           $|$       *Factor*
$7$ Factor    $\mapsto$ ( *Expr* )
$8$           $|$       `num`
$9$           $|$       `name`
--- --------- --------- ----------------------------------

Using the sequence (0,1,4,6,9,9,3,6,9) gives the tree

![](img/03/parsetree5.png)

## Top-down parsing

-   a top-down parser begins with the root of the parse tree and systematically
    extends the tree downwards

-   it selects nonterminals at the lower fringe of the tree and extends it by adding 
    children that correspond to some production for the nonterminal

-   this process continues until either

    a)  the fringe contains only terminals and the input stream has been exhausted, or
    b)  a clear mismatch occurs between the fringe of the partially build parse tree
        and the input stream
 
-   in the first case the parser succeeds

-   in the second case

    -   the parser may have selected the wrong production at some earlier step
        and it can backtrack
    -   or backtracking would also fail, since the input string is not valid

## Top-down parsing ...

-   top-down parsing is efficient for a large subset of the CFGs, since it needs
    no backtracking

-   there exist transformations that can often convert a arbitrary grammar into
    one suitable for backtracking-free top-down parsing

-   there are two distinct techniques for constructing top-down parsers

    1.  hand-coded recursive-decent parsers, and
    2.  generated LL(1) parsers

## Eliminating left recursion

-   using a classic grammar and a leftmost, top-down parser can lead to an infinite
    loop, if the grammar contains *left recursion*, e.g.

    ----- --------- --------------
    *Fee* $\mapsto$ *Fee* $\alpha$
          $|$       $\beta$
    ----- --------- --------------

-   but we can easily eliminate this left recursion by using

    ------ --------- ---------------
    *Fee*  $\mapsto$ $\beta$ *Fee'*
    *Fee'* $\mapsto$ $\alpha$ *Fee'*
           $|$       $\epsilon$
    ------ --------- ---------------

## Exercise

Eliminate left recursion of

--- --------- --------- ----------------------------------
$0$ *Goal*    $\mapsto$ *Expr*
$1$ *Expr*    $\mapsto$ *Expr* + *Term*
$2$           $|$       *Expr* - *Term*
$3$           $|$       *Term*
$4$ *Term*    $\mapsto$ *Term* * *Factor*
$5$           $|$       *Term* / *Factor*
$6$           $|$       *Factor*
$7$ Factor    $\mapsto$ ( *Expr* )
$8$           $|$       `num`
$9$           $|$       `name`
--- --------- --------- ----------------------------------

## Solution

---- --------- --------- ----------------------------------
 $0$ *Goal*    $\mapsto$ *Expr*
 $1$ *Expr*    $\mapsto$ *Term* *Expr'*
 $2$ *Expr'*   $\mapsto$ + *Term* *Expr'*
 $3$           $|$       - *Term* *Expr'*
 $4$           $|$       $\epsilon$
 $5$ *Term*    $\mapsto$ *Factor* *Term'*
 $6$ *Term'*   $\mapsto$ * *Factor* *Term'*
 $7$           $|$       / *Factor* *Term'*
 $8$           $|$       $\epsilon$
 $9$ *Factor*  $\mapsto$  ( *Expr* )
$10$           $|$       `num`
$11$           $|$       `name`
---- --------- --------- ----------------------------------




<!-- vim:spell spelllang=en: -->
