% Compiler  
  --- Die Programmiersprache Go ---
% Prof. Dr. Oliver Braun
% SS 2014

## Warum Go?

-	Computer werden immer schneller, aber Softwareentwicklung nicht

-	Dependency Management ist in Sprachen wie C (header files) zu umständlich und
	bremst den Compiler

-	Typsysteme (Java, C++, ...) sind oft zu schwerfällig, aber dynamische Typisierung
    ist (nach Meinung der Autoren und mir ;-)) auch keine Lösung

-	Garbage Collection und Parallel Computing wird von populären Systemsprachen zu
	wenig unterstützt

-	Multicore, Manycore, ...

-   und ...

---------------

![http://xkcd.com/303/](http://imgs.xkcd.com/comics/compiling.png)

## Go's Antwort

-	großes Go-Programm auf einem einzelnen Rechner in wenigen Sekunden compilierbar
    (High-Speed-Compilation)

-	einfache Abhängigkeiten-Analyse

-	keine Typhierarchie => Compilieren schneller

-	Garbage-Collection, Parallel, Multicore, ...

## Was ist Go?

-	neue Systemsprache

-	entwickelt von Robert Griesemer, Rob Pike (Unix, UTF-8) und
	Ken Thompson (Unix, C, UTF-8) bei Google

-	Start 2007

-	seit 2009 Open Source

-	2012: Go 1.0

-	18.06.14: Go 1.3

## Design von Go

-	keine Generics

	- 	evtl. später, Kosten im Typsystem und bei der Laufzeit

-	keine Exceptions

	-	Exceptions führen zu verwirrendem Code und ermuntern die Programmierer
		normale Fehler wie "file-does-not-exist" als Ausnahmezustand anzusehen

	-	Go hat Fehlerbehandlung über *multi-value returns*, z.B.

		~~~~ {.go}
		f, err := os.Open("filename.ext")
		if err != nil {
    		log.Fatal(err)
		}
		~~~~

-	keine Assertions

	-	verleiten dazu sich zu wenig Gedanken über echte Fehlerbehandlung zu machen

## Design von Go ...

-	Concurrency basiert auf Communication Sequential Processes (CSP)

-	Goroutines statt Threads

	-	viel leichtgewichtiger als Threads

-	OOP? Jein.

	-	Methoden für beliebige Typen implementierbar, z.B. auch für `int`

	-	keine Typhierarchie

	-	Interfaces, die automatisch gecheckt werden

## Design von Go ...

-	kein Überladen von Methoden und Operatoren möglich

	-	Typsystem einfacher, Compiler muss nur Namen checken

-	keine impliziten Typumwandlungen

	-	stiften mehr Verwirrung als sie helfen

	-	Compiler einfacher ohne

## Syntax von Go

-   wenig Schlüsselworte, leichtgewichtig

-   leicht zu analysieren und zu parsen, ohne Symboltabelle

    -   dadurch können auch Tools wie Debugger einfacher implementiert werden

-   Grammatikentscheidungen mit Hinblick auf Parser, z.B.

    ~~~~ {.go}
    var a, b *int
    ~~~~

-   statt

    ~~~~ {.go}
    var a uint64 = 1
    ~~~~

    auch

    ~~~~ {.go}
    a := uint64(1)
    ~~~~

-   und auch Typinferenz

    ~~~~ {.go}
    var a := 2.7
    ~~~~

## Pointer, aber ohne Arithmetik

-   ohne Pointer Arithmetik kann keine illegale Adresse erzeugt werden

-   die Implementierung des Garbage Collectors ist einfacher

-   `++` und `--` sind Anweisungen und keine Ausdrücke und es gibt sie nur
    in Postfix-Notation

## Klammern und Semikolons

-   aus den FAQ: *"Semicolons, however, are for parsers, not for people."*

-   der Scanner fügt automatisch, ohne Lookahead,
    Semikolons an Zeilenenden ein, die eine Anweisung beenden

-   das bedingt aber, dass öffnende geschweifte Klammern nicht in einer neuen
    Zeile stehen dürfen

-   mit der Go-Installation kommt ein Tool `gofmt` zum automatischen
    Formatieren des Quellcodes

    ⇒ der Programmierstil ist keine Geschmackssache, sondern vereinheitlicht

## Abhängigkeiten

-   Explizite Abhängigkeiten für schnellere Compilierung

-   transitive Abhängigkeiten aus der Objektdatei der direkten Abhängigkeit

-   Abhängigkeiten werden statisch gelinkt

    ⇒ große Binaries, aber keine Abhängigkeiten zur Laufzeit, die nicht installiert
      sind

## Goroutines und Channel

-   einfache Nebenläufigkeit/Parallelisierung

    ~~~~ {.go}
    func main() {
	    go expensiveComp(x, y, z)
	    anotherExpensiveComp(a, b, c)
    }
    ~~~~

-   Kommunikation/Synchronisation durch Channels

    ~~~~ {.go}
    func computeAndSend(ch chan int, x, y, z int) {
    	ch <- expensiveComputation(x, y, z)
    }
    
    func main() {
    	ch := make(chan int)
    	go computeAndSend(ch, x, y, z)
    	v2 := anotherExpensiveComputation(a, b, c)
    	v1 := <-ch
    	fmt.Println(v1, v2)
    }
    ~~~~

## Mehr Infos unter

### <http://golang.org/>

<!-- vim:spell spelllang=de: -->
